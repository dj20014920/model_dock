import { FetchError, ofetch } from 'ofetch'
import Browser from 'webextension-polyfill'
import { requestHostPermission } from '~app/utils/permissions'
import { ChatError, ErrorCode } from '~utils/errors'
import { streamAsyncIterable } from '~utils/stream-async-iterable'
import { AbstractBot, SendMessageParams } from '../abstract-bot'
import { getUserConfig } from '~services/user-config'

const DEFAULT_AUTHORIZATION =
  'Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs=1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA'

// ì¬ì‹œë„ ì„¤ì •
const MAX_RETRIES = 3
const RETRY_DELAY_MS = 1000
const REQUEST_TIMEOUT_MS = 60000

interface StreamMessage {
  result: {
    sender: string
    message: string
    query: string
  }
}

interface ChatMessage {
  sender: 1 | 2
  message: string
}

interface ConversationContext {
  conversationId: string
  messages: ChatMessage[]
  lastMessageTime: number
}

export class GrokWebBot extends AbstractBot {
  private csrfToken?: string
  private conversationContext?: ConversationContext
  private requestCount = 0
  private cachedAuth?: string

  constructor() {
    super()
  }

  /**
   * ì¬ì‹œë„ ë¡œì§ì´ í¬í•¨ëœ ë©”ì‹œì§€ ì „ì†¡
   */
  async doSendMessage(params: SendMessageParams) {
    console.log('[GROK-WEB] ğŸš€ Starting message send...')
    
    let lastError: Error | undefined
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        console.log(`[GROK-WEB] ğŸ”„ Attempt ${attempt}/${MAX_RETRIES}`)
        await this.doSendMessageInternal(params)
        console.log('[GROK-WEB] âœ… Message sent successfully')
        return
      } catch (error) {
        lastError = error as Error
        console.error(`[GROK-WEB] âŒ Attempt ${attempt} failed:`, error)

        // ì¬ì‹œë„ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬ëŠ” ì¦‰ì‹œ throw
        if (error instanceof ChatError) {
          if (
            error.code === ErrorCode.MISSING_HOST_PERMISSION ||
            error.code === ErrorCode.TWITTER_UNAUTHORIZED ||
            error.code === ErrorCode.GROK_UNAVAILABLE
          ) {
            throw error
          }
        }

        // ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ì¬ì‹œë„
        if (attempt < MAX_RETRIES) {
          const delay = RETRY_DELAY_MS * attempt
          console.log(`[GROK-WEB] â³ Retrying in ${delay}ms...`)
          await new Promise((resolve) => setTimeout(resolve, delay))
          
          // CSRF í† í° ë° conversation ì´ˆê¸°í™”í•˜ì—¬ ì¬ì‹œë„
          this.csrfToken = undefined
          this.conversationContext = undefined
        }
      }
    }

    // ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨
    console.error('[GROK-WEB] âŒ All retries failed')
    throw lastError || new ChatError('Failed to send message after retries', ErrorCode.UNKOWN_ERROR)
  }

  /**
   * ì‹¤ì œ ë©”ì‹œì§€ ì „ì†¡ ë¡œì§
   */
  private async doSendMessageInternal(params: SendMessageParams) {
    // ê¶Œí•œ í™•ì¸
    if (!(await requestHostPermission('https://*.twitter.com/'))) {
      throw new ChatError('Missing twitter.com permission', ErrorCode.MISSING_HOST_PERMISSION)
    }

    // CSRF í† í° í™•ë³´
    if (!this.csrfToken) {
      console.log('[GROK-WEB] ğŸ”‘ Getting CSRF token...')
      this.csrfToken = await this.readCsrfToken()
      console.log('[GROK-WEB] âœ… CSRF token obtained')
    }

    // Conversation ì´ˆê¸°í™” ë˜ëŠ” ì¬ì‚¬ìš©
    if (!this.conversationContext) {
      console.log('[GROK-WEB] ğŸ’¬ Creating new conversation...')
      const conversationId = await this.getConversationId()
      this.conversationContext = { 
        conversationId, 
        messages: [],
        lastMessageTime: Date.now()
      }
      console.log('[GROK-WEB] âœ… Conversation created:', conversationId)
    } else {
      // ì˜¤ë˜ëœ conversationì€ ìƒˆë¡œ ìƒì„±
      const timeSinceLastMessage = Date.now() - this.conversationContext.lastMessageTime
      if (timeSinceLastMessage > 30 * 60 * 1000) { // 30ë¶„ ì´ìƒ ê²½ê³¼
        console.log('[GROK-WEB] â° Conversation too old, creating new one...')
        this.conversationContext = undefined
        return this.doSendMessageInternal(params)
      }
      console.log('[GROK-WEB] â™»ï¸ Reusing existing conversation')
    }

    // ë©”ì‹œì§€ ì¶”ê°€
    this.conversationContext.messages.push({ sender: 1, message: params.prompt })
    this.conversationContext.lastMessageTime = Date.now()
    this.requestCount++

    console.log('[GROK-WEB] ğŸ“¡ Sending request to Grok API...')
    
    // íƒ€ì„ì•„ì›ƒ ì„¤ì •
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS)
    
    try {
      const auth = await this.getAuthorizationValue()
      const resp = await fetch('https://api.twitter.com/2/grok/add_response.json', {
        method: 'POST',
        headers: {
          Authorization: auth,
          'x-csrf-token': this.csrfToken!,
        },
        body: JSON.stringify({
          conversationId: this.conversationContext.conversationId,
          responses: this.conversationContext.messages,
          systemPromptName: 'fun',
        }),
        signal: params.signal || controller.signal,
      })

      clearTimeout(timeoutId)

      // ì‘ë‹µ ìƒíƒœ í™•ì¸
      if (!resp.ok) {
        await this.handleErrorResponse(resp)
      }

      console.log('[GROK-WEB] âœ… Response received, parsing stream...')
      await this.parseStreamResponse(resp, params)
      
    } catch (error) {
      clearTimeout(timeoutId)
      
      if ((error as Error).name === 'AbortError') {
        throw new ChatError('Request timeout', ErrorCode.NETWORK_ERROR)
      }
      throw error
    }
  }

  /**
   * ì—ëŸ¬ ì‘ë‹µ ì²˜ë¦¬
   */
  private async handleErrorResponse(resp: Response) {
    const statusText = await resp.text().catch(() => 'Unknown error')
    console.error('[GROK-WEB] âŒ Error response:', resp.status, statusText)

    switch (resp.status) {
      case 401:
        throw new ChatError(
          'Grok requires an X (Twitter) account.\n\nâ„¹ï¸ All X users get limited free Grok access.\n\nPlease log into X (Twitter) in this browser.',
          ErrorCode.GROK_UNAVAILABLE
        )
      case 403:
        // CSRF í† í° ê°±ì‹  í›„ ì¬ì‹œë„
        console.log('[GROK-WEB] ğŸ”„ CSRF mismatch, refreshing token...')
        this.csrfToken = await this.readCsrfToken({ refresh: true })
        throw new Error('CSRF token refreshed, retry needed')
      case 429:
        throw new ChatError(
          'Daily Grok limit reached.\n\nâ„¹ï¸ Free users have limited messages.\nPlease wait or upgrade to Premium+.',
          ErrorCode.CONVERSATION_LIMIT
        )
      case 451:
        throw new ChatError('Grok is not available in your region.', ErrorCode.GROK_UNAVAILABLE)
      case 503:
        throw new ChatError('Grok service is temporarily unavailable. Please try again later.', ErrorCode.NETWORK_ERROR)
      default:
        throw new Error(`${resp.status}: ${statusText}`)
    }
  }

  /**
   * ìŠ¤íŠ¸ë¦¼ ì‘ë‹µ íŒŒì‹±
   */
  private async parseStreamResponse(resp: Response, params: SendMessageParams) {
    const decoder = new TextDecoder()
    let result = ''
    let buffer = '' // ë¶ˆì™„ì „í•œ JSON ì²­í¬ë¥¼ ìœ„í•œ ë²„í¼

    for await (const uint8Array of streamAsyncIterable(resp.body!)) {
      const str = decoder.decode(uint8Array, { stream: true })
      buffer += str
      
      const lines = buffer.split('\n')
      buffer = lines.pop() || '' // ë§ˆì§€ë§‰ ë¶ˆì™„ì „í•œ ì¤„ ë³´ê´€

      for (const line of lines) {
        if (!line.trim()) continue

        try {
          const payload: StreamMessage = JSON.parse(line)
          
          if (!payload.result) continue

          // ì¿¼ë¦¬ í‘œì‹œ (ì²« ì‘ë‹µ)
          if (!result && !payload.result.message && payload.result.query) {
            params.onEvent({ type: 'UPDATE_ANSWER', data: { text: '_' + payload.result.query + '_' } })
            continue
          }

          // ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
          const text = payload.result.message
          if (text) {
            // Twitter ì¹´ë“œ ë§í¬ëŠ” ê±´ë„ˆë›°ê¸°
            if (text.startsWith('[link]')) {
              console.debug('[GROK-WEB] ğŸ”— Skipping Twitter card link')
              continue
            }
            
            result += text
            params.onEvent({ type: 'UPDATE_ANSWER', data: { text: result } })
          }
        } catch (parseError) {
          console.warn('[GROK-WEB] âš ï¸ Failed to parse stream line:', line, parseError)
          // JSON íŒŒì‹± ì˜¤ë¥˜ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
        }
      }
    }

    // ì‘ë‹µì„ conversationì— ì¶”ê°€
    this.conversationContext!.messages.push({ sender: 2, message: result })
    this.conversationContext!.lastMessageTime = Date.now()
    
    console.log('[GROK-WEB] âœ… Stream parsing complete, chars:', result.length)
    params.onEvent({ type: 'DONE' })
  }

  /**
   * Conversation ID íšë“
   */
  private async getConversationId(): Promise<string> {
    console.log('[GROK-WEB] ğŸ†” Requesting conversation ID...')
    const auth = await this.getAuthorizationValue()
    try {
      const resp = await ofetch('https://twitter.com/i/api/2/grok/conversation_id.json', {
        headers: {
          Authorization: auth,
          'x-csrf-token': this.csrfToken!,
        },
        timeout: 10000, // 10ì´ˆ íƒ€ì„ì•„ì›ƒ
      })
      
      console.log('[GROK-WEB] âœ… Conversation ID obtained:', resp.conversationId)
      return resp.conversationId
    } catch (err) {
      console.error('[GROK-WEB] âŒ Failed to get conversation ID:', err)
      
      if (err instanceof FetchError) {
        if (err.status === 401) {
          throw new ChatError(
            'Grok requires an X (Twitter) account.\n\nâ„¹ï¸ All X users get limited free Grok access daily.\n\nPlease ensure:\n1. You are logged into X (Twitter)\n2. Your account has Grok access enabled\n\nNote: Premium+ subscribers get priority access and higher limits.',
            ErrorCode.GROK_UNAVAILABLE
          )
        }
        if (err.status === 451) {
          throw new ChatError(
            'Grok is not available in your region.\n\nPlease check Grok availability in your country.',
            ErrorCode.GROK_UNAVAILABLE
          )
        }
        // CSRF & cookie mismatch - ìë™ ê°±ì‹  í›„ ì¬ì‹œë„
        if (err.status === 403) {
          console.log('[GROK-WEB] ğŸ”„ CSRF token mismatch, refreshing...')
          this.csrfToken = await this.readCsrfToken({ refresh: true })
          return this.getConversationId()
        }
        if (err.status === 429) {
          throw new ChatError(
            'Daily Grok limit reached.\n\nâ„¹ï¸ Free users: Limited daily messages\nâ„¹ï¸ Premium+ users: Higher limits\n\nPlease wait until tomorrow or upgrade for more access.',
            ErrorCode.CONVERSATION_LIMIT
          )
        }
      }
      throw err
    }
  }

  /**
   * Authorization í—¤ë” ê°’ íšë“(í™˜ê²½ì„¤ì • ìš°ì„ , ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
   */
  private async getAuthorizationValue(): Promise<string> {
    if (this.cachedAuth) return this.cachedAuth
    try {
      const cfg = await getUserConfig()
      const override = (cfg as any).grokWebAuthorization
      if (typeof override === 'string' && override.trim()) {
        this.cachedAuth = override.trim()
        console.debug('[GROK-WEB] Using custom Authorization value (config)')
        return this.cachedAuth
      }
    } catch {}
    this.cachedAuth = DEFAULT_AUTHORIZATION
    return this.cachedAuth
  }

  /**
   * CSRF í† í° ì½ê¸°
   */
  private async readCsrfToken({ refresh }: { refresh?: boolean } = {}): Promise<string> {
    console.log(`[GROK-WEB] ğŸ”‘ Reading CSRF token (refresh: ${refresh})...`)
    
    try {
      const token = await Browser.runtime.sendMessage({
        type: 'read-twitter-csrf-token',
        data: { refresh },
        target: 'background',
      })
      
      if (!token) {
        throw new ChatError(
          'No X (Twitter) account found.\n\nPlease:\n1. Log into X (Twitter) in this browser\n2. Ensure you have Grok access\n\nâ„¹ï¸ All X users get free Grok access (with daily limits).',
          ErrorCode.TWITTER_UNAUTHORIZED
        )
      }
      
      console.log('[GROK-WEB] âœ… CSRF token obtained:', token.substring(0, 8) + '...')
      return token
    } catch (error) {
      console.error('[GROK-WEB] âŒ Failed to read CSRF token:', error)
      throw error
    }
  }

  resetConversation() {
    console.log('[GROK-WEB] ğŸ”„ Resetting conversation context')
    this.conversationContext = undefined
    this.requestCount = 0
  }

  get name() {
    return 'Grok'
  }
}
